============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/masahiro/work/dom-enterprise-gateway/backend
configfile: pyproject.toml
plugins: langsmith-0.4.55, anyio-4.12.0, asyncio-0.23.8
asyncio: mode=Mode.STRICT
collected 54 items

app/tests/test_auth_service.py ......                                    [ 11%]
app/tests/test_chat_service.py ...                                       [ 16%]
app/tests/test_dom_orchestrator_service.py F..                           [ 22%]
app/tests/test_endpoints_admin.py ...                                    [ 27%]
app/tests/test_endpoints_auth.py ..F..                                   [ 37%]
app/tests/test_endpoints_chat.py ....FFF                                 [ 50%]
app/tests/test_endpoints_feedback.py FFFFF                               [ 59%]
app/tests/test_endpoints_files.py FFFF                                   [ 66%]
app/tests/test_main.py .                                                 [ 68%]
app/tests/test_memory_service.py .......                                 [ 81%]
app/tests/test_rag_service.py FEEE                                       [ 88%]
app/tests/test_repositories.py FF.FFF                                    [100%]

==================================== ERRORS ====================================
_______________________ ERROR at setup of test_query_rag _______________________

mock_tenant_id = UUID('99e8dcd3-ce98-4845-91ce-9a2fcfda1242')
mock_llm_client = <AsyncMock spec='MockLLMClient' id='140288743570416'>
mock_pgvector = <MagicMock name='PGVector' spec='PGVector' id='140288743571184'>
mock_embeddings = <MagicMock name='GoogleGenerativeAIEmbeddings' spec='GoogleGenerativeAIEmbeddings' id='140288774403184'>
mock_chat_google_generative_ai = <MagicMock name='ChatGoogleGenerativeAI' spec='ChatGoogleGenerativeAI' id='140288770431152'>

    @pytest.fixture
    def rag_service(
        mock_tenant_id,
        mock_llm_client,
        mock_pgvector,
        mock_embeddings,
        mock_chat_google_generative_ai
    ):
        """RagServiceのフィクスチャ"""
>       service = RagService(tenant_id=mock_tenant_id, llm_client=mock_llm_client)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app/tests/test_rag_service.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/rag_service.py:29: in __init__
    self.global_vectorstore = PGVector(
/usr/lib/python3.12/unittest/mock.py:1132: in __call__
    self._mock_check_sig(*args, **kwargs)
/usr/lib/python3.12/unittest/mock.py:131: in checksig
    sig.bind(*args, **kwargs)
/usr/lib/python3.12/inspect.py:3242: in bind
    return self._bind(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Signature (embeddings: 'Embeddings', *, connection: 'Union[None, DBConnection, Engine, AsyncEngine, str]' = None, emb...t[str, Any]]' = None, use_jsonb: 'bool' = True, create_extension: 'bool' = True, async_mode: 'bool' = False) -> 'None'>
args = ()
kwargs = {'connection_string': 'postgresql+asyncpg://user:password@localhost:5432/dom_gateway'}

    def _bind(self, args, kwargs, *, partial=False):
        """Private method. Don't use directly."""
    
        arguments = {}
    
        parameters = iter(self.parameters.values())
        parameters_ex = ()
        arg_vals = iter(args)
    
        while True:
            # Let's iterate through the positional arguments and corresponding
            # parameters
            try:
                arg_val = next(arg_vals)
            except StopIteration:
                # No more positional arguments
                try:
                    param = next(parameters)
                except StopIteration:
                    # No more parameters. That's it. Just need to check that
                    # we have no `kwargs` after this while loop
                    break
                else:
                    if param.kind == _VAR_POSITIONAL:
                        # That's OK, just empty *args.  Let's start parsing
                        # kwargs
                        break
                    elif param.name in kwargs:
                        if param.kind == _POSITIONAL_ONLY:
                            msg = '{arg!r} parameter is positional only, ' \
                                  'but was passed as a keyword'
                            msg = msg.format(arg=param.name)
                            raise TypeError(msg) from None
                        parameters_ex = (param,)
                        break
                    elif (param.kind == _VAR_KEYWORD or
                                                param.default is not _empty):
                        # That's fine too - we have a default value for this
                        # parameter.  So, lets start parsing `kwargs`, starting
                        # with the current parameter
                        parameters_ex = (param,)
                        break
                    else:
                        # No default, not VAR_KEYWORD, not VAR_POSITIONAL,
                        # not in `kwargs`
                        if partial:
                            parameters_ex = (param,)
                            break
                        else:
                            if param.kind == _KEYWORD_ONLY:
                                argtype = ' keyword-only'
                            else:
                                argtype = ''
                            msg = 'missing a required{argtype} argument: {arg!r}'
                            msg = msg.format(arg=param.name, argtype=argtype)
                            raise TypeError(msg) from None
            else:
                # We have a positional argument to process
                try:
                    param = next(parameters)
                except StopIteration:
                    raise TypeError('too many positional arguments') from None
                else:
                    if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
                        # Looks like we have no parameter for this positional
                        # argument
                        raise TypeError(
                            'too many positional arguments') from None
    
                    if param.kind == _VAR_POSITIONAL:
                        # We have an '*args'-like argument, let's fill it with
                        # all positional arguments we have left and move on to
                        # the next phase
                        values = [arg_val]
                        values.extend(arg_vals)
                        arguments[param.name] = tuple(values)
                        break
    
                    if param.name in kwargs and param.kind != _POSITIONAL_ONLY:
                        raise TypeError(
                            'multiple values for argument {arg!r}'.format(
                                arg=param.name)) from None
    
                    arguments[param.name] = arg_val
    
        # Now, we iterate through the remaining parameters to process
        # keyword arguments
        kwargs_param = None
        for param in itertools.chain(parameters_ex, parameters):
            if param.kind == _VAR_KEYWORD:
                # Memorize that we have a '**kwargs'-like parameter
                kwargs_param = param
                continue
    
            if param.kind == _VAR_POSITIONAL:
                # Named arguments don't refer to '*args'-like parameters.
                # We only arrive here if the positional arguments ended
                # before reaching the last parameter before *args.
                continue
    
            param_name = param.name
            try:
                arg_val = kwargs.pop(param_name)
            except KeyError:
                # We have no value for this parameter.  It's fine though,
                # if it has a default value, or it is an '*args'-like
                # parameter, left alone by the processing of positional
                # arguments.
                if (not partial and param.kind != _VAR_POSITIONAL and
                                                    param.default is _empty):
                    raise TypeError('missing a required argument: {arg!r}'. \
                                    format(arg=param_name)) from None
    
            else:
                if param.kind == _POSITIONAL_ONLY:
                    # This should never happen in case of a properly built
                    # Signature object (but let's have this check here
                    # to ensure correct behaviour just in case)
                    raise TypeError('{arg!r} parameter is positional only, '
                                    'but was passed as a keyword'. \
                                    format(arg=param.name))
    
                arguments[param_name] = arg_val
    
        if kwargs:
            if kwargs_param is not None:
                # Process our '**kwargs'-like parameter
                arguments[kwargs_param.name] = kwargs
            else:
>               raise TypeError(
                    'got an unexpected keyword argument {arg!r}'.format(
                        arg=next(iter(kwargs))))
E               TypeError: got an unexpected keyword argument 'connection_string'

/usr/lib/python3.12/inspect.py:3231: TypeError
_____________________ ERROR at setup of test_add_documents _____________________

mock_tenant_id = UUID('82a1bb33-03f2-4c1a-a9f5-f73bc540410a')
mock_llm_client = <AsyncMock spec='MockLLMClient' id='140288747120752'>
mock_pgvector = <MagicMock name='PGVector' spec='PGVector' id='140288747118688'>
mock_embeddings = <MagicMock name='GoogleGenerativeAIEmbeddings' spec='GoogleGenerativeAIEmbeddings' id='140288745927792'>
mock_chat_google_generative_ai = <MagicMock name='ChatGoogleGenerativeAI' spec='ChatGoogleGenerativeAI' id='140288740972528'>

    @pytest.fixture
    def rag_service(
        mock_tenant_id,
        mock_llm_client,
        mock_pgvector,
        mock_embeddings,
        mock_chat_google_generative_ai
    ):
        """RagServiceのフィクスチャ"""
>       service = RagService(tenant_id=mock_tenant_id, llm_client=mock_llm_client)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app/tests/test_rag_service.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/rag_service.py:29: in __init__
    self.global_vectorstore = PGVector(
/usr/lib/python3.12/unittest/mock.py:1132: in __call__
    self._mock_check_sig(*args, **kwargs)
/usr/lib/python3.12/unittest/mock.py:131: in checksig
    sig.bind(*args, **kwargs)
/usr/lib/python3.12/inspect.py:3242: in bind
    return self._bind(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Signature (embeddings: 'Embeddings', *, connection: 'Union[None, DBConnection, Engine, AsyncEngine, str]' = None, emb...t[str, Any]]' = None, use_jsonb: 'bool' = True, create_extension: 'bool' = True, async_mode: 'bool' = False) -> 'None'>
args = ()
kwargs = {'connection_string': 'postgresql+asyncpg://user:password@localhost:5432/dom_gateway'}

    def _bind(self, args, kwargs, *, partial=False):
        """Private method. Don't use directly."""
    
        arguments = {}
    
        parameters = iter(self.parameters.values())
        parameters_ex = ()
        arg_vals = iter(args)
    
        while True:
            # Let's iterate through the positional arguments and corresponding
            # parameters
            try:
                arg_val = next(arg_vals)
            except StopIteration:
                # No more positional arguments
                try:
                    param = next(parameters)
                except StopIteration:
                    # No more parameters. That's it. Just need to check that
                    # we have no `kwargs` after this while loop
                    break
                else:
                    if param.kind == _VAR_POSITIONAL:
                        # That's OK, just empty *args.  Let's start parsing
                        # kwargs
                        break
                    elif param.name in kwargs:
                        if param.kind == _POSITIONAL_ONLY:
                            msg = '{arg!r} parameter is positional only, ' \
                                  'but was passed as a keyword'
                            msg = msg.format(arg=param.name)
                            raise TypeError(msg) from None
                        parameters_ex = (param,)
                        break
                    elif (param.kind == _VAR_KEYWORD or
                                                param.default is not _empty):
                        # That's fine too - we have a default value for this
                        # parameter.  So, lets start parsing `kwargs`, starting
                        # with the current parameter
                        parameters_ex = (param,)
                        break
                    else:
                        # No default, not VAR_KEYWORD, not VAR_POSITIONAL,
                        # not in `kwargs`
                        if partial:
                            parameters_ex = (param,)
                            break
                        else:
                            if param.kind == _KEYWORD_ONLY:
                                argtype = ' keyword-only'
                            else:
                                argtype = ''
                            msg = 'missing a required{argtype} argument: {arg!r}'
                            msg = msg.format(arg=param.name, argtype=argtype)
                            raise TypeError(msg) from None
            else:
                # We have a positional argument to process
                try:
                    param = next(parameters)
                except StopIteration:
                    raise TypeError('too many positional arguments') from None
                else:
                    if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
                        # Looks like we have no parameter for this positional
                        # argument
                        raise TypeError(
                            'too many positional arguments') from None
    
                    if param.kind == _VAR_POSITIONAL:
                        # We have an '*args'-like argument, let's fill it with
                        # all positional arguments we have left and move on to
                        # the next phase
                        values = [arg_val]
                        values.extend(arg_vals)
                        arguments[param.name] = tuple(values)
                        break
    
                    if param.name in kwargs and param.kind != _POSITIONAL_ONLY:
                        raise TypeError(
                            'multiple values for argument {arg!r}'.format(
                                arg=param.name)) from None
    
                    arguments[param.name] = arg_val
    
        # Now, we iterate through the remaining parameters to process
        # keyword arguments
        kwargs_param = None
        for param in itertools.chain(parameters_ex, parameters):
            if param.kind == _VAR_KEYWORD:
                # Memorize that we have a '**kwargs'-like parameter
                kwargs_param = param
                continue
    
            if param.kind == _VAR_POSITIONAL:
                # Named arguments don't refer to '*args'-like parameters.
                # We only arrive here if the positional arguments ended
                # before reaching the last parameter before *args.
                continue
    
            param_name = param.name
            try:
                arg_val = kwargs.pop(param_name)
            except KeyError:
                # We have no value for this parameter.  It's fine though,
                # if it has a default value, or it is an '*args'-like
                # parameter, left alone by the processing of positional
                # arguments.
                if (not partial and param.kind != _VAR_POSITIONAL and
                                                    param.default is _empty):
                    raise TypeError('missing a required argument: {arg!r}'. \
                                    format(arg=param_name)) from None
    
            else:
                if param.kind == _POSITIONAL_ONLY:
                    # This should never happen in case of a properly built
                    # Signature object (but let's have this check here
                    # to ensure correct behaviour just in case)
                    raise TypeError('{arg!r} parameter is positional only, '
                                    'but was passed as a keyword'. \
                                    format(arg=param.name))
    
                arguments[param_name] = arg_val
    
        if kwargs:
            if kwargs_param is not None:
                # Process our '**kwargs'-like parameter
                arguments[kwargs_param.name] = kwargs
            else:
>               raise TypeError(
                    'got an unexpected keyword argument {arg!r}'.format(
                        arg=next(iter(kwargs))))
E               TypeError: got an unexpected keyword argument 'connection_string'

/usr/lib/python3.12/inspect.py:3231: TypeError
__________________ ERROR at setup of test_stream_rag_response __________________

mock_tenant_id = UUID('1c0bbbc3-de74-4ed1-9396-abe316c721fa')
mock_llm_client = <AsyncMock spec='MockLLMClient' id='140288748232896'>
mock_pgvector = <MagicMock name='PGVector' spec='PGVector' id='140288748230064'>
mock_embeddings = <MagicMock name='GoogleGenerativeAIEmbeddings' spec='GoogleGenerativeAIEmbeddings' id='140288770517728'>
mock_chat_google_generative_ai = <MagicMock name='ChatGoogleGenerativeAI' spec='ChatGoogleGenerativeAI' id='140288750587488'>

    @pytest.fixture
    def rag_service(
        mock_tenant_id,
        mock_llm_client,
        mock_pgvector,
        mock_embeddings,
        mock_chat_google_generative_ai
    ):
        """RagServiceのフィクスチャ"""
>       service = RagService(tenant_id=mock_tenant_id, llm_client=mock_llm_client)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app/tests/test_rag_service.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/rag_service.py:29: in __init__
    self.global_vectorstore = PGVector(
/usr/lib/python3.12/unittest/mock.py:1132: in __call__
    self._mock_check_sig(*args, **kwargs)
/usr/lib/python3.12/unittest/mock.py:131: in checksig
    sig.bind(*args, **kwargs)
/usr/lib/python3.12/inspect.py:3242: in bind
    return self._bind(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Signature (embeddings: 'Embeddings', *, connection: 'Union[None, DBConnection, Engine, AsyncEngine, str]' = None, emb...t[str, Any]]' = None, use_jsonb: 'bool' = True, create_extension: 'bool' = True, async_mode: 'bool' = False) -> 'None'>
args = ()
kwargs = {'connection_string': 'postgresql+asyncpg://user:password@localhost:5432/dom_gateway'}

    def _bind(self, args, kwargs, *, partial=False):
        """Private method. Don't use directly."""
    
        arguments = {}
    
        parameters = iter(self.parameters.values())
        parameters_ex = ()
        arg_vals = iter(args)
    
        while True:
            # Let's iterate through the positional arguments and corresponding
            # parameters
            try:
                arg_val = next(arg_vals)
            except StopIteration:
                # No more positional arguments
                try:
                    param = next(parameters)
                except StopIteration:
                    # No more parameters. That's it. Just need to check that
                    # we have no `kwargs` after this while loop
                    break
                else:
                    if param.kind == _VAR_POSITIONAL:
                        # That's OK, just empty *args.  Let's start parsing
                        # kwargs
                        break
                    elif param.name in kwargs:
                        if param.kind == _POSITIONAL_ONLY:
                            msg = '{arg!r} parameter is positional only, ' \
                                  'but was passed as a keyword'
                            msg = msg.format(arg=param.name)
                            raise TypeError(msg) from None
                        parameters_ex = (param,)
                        break
                    elif (param.kind == _VAR_KEYWORD or
                                                param.default is not _empty):
                        # That's fine too - we have a default value for this
                        # parameter.  So, lets start parsing `kwargs`, starting
                        # with the current parameter
                        parameters_ex = (param,)
                        break
                    else:
                        # No default, not VAR_KEYWORD, not VAR_POSITIONAL,
                        # not in `kwargs`
                        if partial:
                            parameters_ex = (param,)
                            break
                        else:
                            if param.kind == _KEYWORD_ONLY:
                                argtype = ' keyword-only'
                            else:
                                argtype = ''
                            msg = 'missing a required{argtype} argument: {arg!r}'
                            msg = msg.format(arg=param.name, argtype=argtype)
                            raise TypeError(msg) from None
            else:
                # We have a positional argument to process
                try:
                    param = next(parameters)
                except StopIteration:
                    raise TypeError('too many positional arguments') from None
                else:
                    if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
                        # Looks like we have no parameter for this positional
                        # argument
                        raise TypeError(
                            'too many positional arguments') from None
    
                    if param.kind == _VAR_POSITIONAL:
                        # We have an '*args'-like argument, let's fill it with
                        # all positional arguments we have left and move on to
                        # the next phase
                        values = [arg_val]
                        values.extend(arg_vals)
                        arguments[param.name] = tuple(values)
                        break
    
                    if param.name in kwargs and param.kind != _POSITIONAL_ONLY:
                        raise TypeError(
                            'multiple values for argument {arg!r}'.format(
                                arg=param.name)) from None
    
                    arguments[param.name] = arg_val
    
        # Now, we iterate through the remaining parameters to process
        # keyword arguments
        kwargs_param = None
        for param in itertools.chain(parameters_ex, parameters):
            if param.kind == _VAR_KEYWORD:
                # Memorize that we have a '**kwargs'-like parameter
                kwargs_param = param
                continue
    
            if param.kind == _VAR_POSITIONAL:
                # Named arguments don't refer to '*args'-like parameters.
                # We only arrive here if the positional arguments ended
                # before reaching the last parameter before *args.
                continue
    
            param_name = param.name
            try:
                arg_val = kwargs.pop(param_name)
            except KeyError:
                # We have no value for this parameter.  It's fine though,
                # if it has a default value, or it is an '*args'-like
                # parameter, left alone by the processing of positional
                # arguments.
                if (not partial and param.kind != _VAR_POSITIONAL and
                                                    param.default is _empty):
                    raise TypeError('missing a required argument: {arg!r}'. \
                                    format(arg=param_name)) from None
    
            else:
                if param.kind == _POSITIONAL_ONLY:
                    # This should never happen in case of a properly built
                    # Signature object (but let's have this check here
                    # to ensure correct behaviour just in case)
                    raise TypeError('{arg!r} parameter is positional only, '
                                    'but was passed as a keyword'. \
                                    format(arg=param.name))
    
                arguments[param_name] = arg_val
    
        if kwargs:
            if kwargs_param is not None:
                # Process our '**kwargs'-like parameter
                arguments[kwargs_param.name] = kwargs
            else:
>               raise TypeError(
                    'got an unexpected keyword argument {arg!r}'.format(
                        arg=next(iter(kwargs))))
E               TypeError: got an unexpected keyword argument 'connection_string'

/usr/lib/python3.12/inspect.py:3231: TypeError
=================================== FAILURES ===================================
________________ test_process_chat_message_ic5_light_streaming _________________

dom_orchestrator_service = <app.services.dom_orchestrator.DomOrchestratorService object at 0x7f9786a958e0>
mock_llm_client = <AsyncMock spec='MockLLMClient' id='140288776034768'>
mock_answer_composer_service = <AsyncMock spec='AnswerComposerService' id='140288776038368'>
mock_rag_service = <AsyncMock spec='RagService' id='140288776039232'>

    @pytest.mark.asyncio
    async def test_process_chat_message_ic5_light_streaming(
        dom_orchestrator_service,
        mock_llm_client,
        mock_answer_composer_service,
        mock_rag_service # New fixture
    ):
        """
        DomOrchestratorServiceがLLM応答をIC-5ライト形式に整形してストリーミングするテスト。
        (Research Mode OFF)
        """
        test_prompt = "Test prompt for IC-5"
        test_session_id = str(uuid4()) # strに変換
        raw_llm_output_mock = "Decision: Test Decision. Why: Test Why. Next 3 Actions: Test Action 1, Test Action 2, Test Action 3."
    
        # Mock LLM Client to stream tokens
        async def mock_llm_stream():
            for token in raw_llm_output_mock.split(" "):
                yield token + " "
            yield "[END]"
        mock_llm_client.stream_chat_response.return_value = mock_llm_stream()
    
        # Mock AnswerComposerService to return formatted dictionary
        mock_answer_composer_service.compose_ic5_light_response.return_value = {
            "Decision": "Test Decision.",
            "Why": "Test Why.",
            "Next 3 Actions": "Test Action 1, Test Action 2, Test Action 3."
        }
    
        # ストリーミング応答の収集
        streamed_output = ""
        async for chunk in dom_orchestrator_service.process_chat_message(test_prompt, test_session_id, is_research_mode=False):
            streamed_output += chunk
    
        # 検証
        mock_llm_client.stream_chat_response.assert_called_once_with(test_prompt) # RAGなしなので元のプロンプト
>       mock_answer_composer_service.compose_ic5_light_response.assert_awaited_once_with(raw_llm_output_mock.strip())

app/tests/test_dom_orchestrator_service.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:2334: in assert_awaited_once_with
    return self.assert_awaited_with(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncMock name='mock.compose_ic5_light_response' id='140288776041200'>
args = ('Decision: Test Decision. Why: Test Why. Next 3 Actions: Test Action 1, Test Action 2, Test Action 3.',)
kwargs = {}
expected = call('Decision: Test Decision. Why: Test Why. Next 3 Actions: Test Action 1, Test Action 2, Test Action 3.')
_error_message = <function AsyncMockMixin.assert_awaited_with.<locals>._error_message at 0x7f9786a85f80>
actual = call('Decision: Test Decision. Why: Test Why. Next 3 Actions: Test Action 1, Test Action 2, Test Action 3. ')
cause = None

    def assert_awaited_with(self, /, *args, **kwargs):
        """
        Assert that the last await was with the specified arguments.
        """
        if self.await_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            raise AssertionError(f'Expected await: {expected}\nNot awaited')
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs, action='await')
            return msg
    
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.await_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected await not found.
E           Expected: compose_ic5_light_response('Decision: Test Decision. Why: Test Why. Next 3 Actions: Test Action 1, Test Action 2, Test Action 3.')
E             Actual: compose_ic5_light_response('Decision: Test Decision. Why: Test Why. Next 3 Actions: Test Action 1, Test Action 2, Test Action 3. ')

/usr/lib/python3.12/unittest/mock.py:2323: AssertionError
_____________________ test_read_current_user_inactive_user _____________________

mock_auth_service = <AsyncMock spec='AuthService' id='140288776040096'>
override_get_auth_service = None

    def test_read_current_user_inactive_user(mock_auth_service, override_get_auth_service):
        """
        非アクティブユーザーの認証失敗ケースをテストします。
        """
        inactive_user = AuthenticatedUser(
            id=uuid4(),
            tenant_id=uuid4(),
            email="inactive@example.com",
            is_active=False,
            is_admin=False
        )
        mock_auth_service.verify_id_token.return_value = inactive_user
    
        response = client.get("/api/v1/auth/me", headers={"Authorization": "Bearer valid_token"})
>       assert response.status_code == 400
E       assert 401 == 400
E        +  where 401 = <Response [401 Unauthorized]>.status_code

app/tests/test_endpoints_auth.py:80: AssertionError
______________________ test_stream_chat_response_success _______________________

override_get_current_user = None, override_get_chat_session_repository = None
override_get_chat_message_repository = None
override_get_dom_orchestrator_service = None
mock_current_user = AuthenticatedUser(id=UUID('7db5ac60-d6fc-45d1-a689-2b5f952479f8'), tenant_id=UUID('907dd4a9-b721-49be-bc3d-300680681d78'), email='test@example.com', is_active=True, is_admin=False)
mock_chat_session_repo = <AsyncMock spec='ChatSessionRepository' id='140288778389696'>
mock_chat_message_repo = <AsyncMock spec='ChatMessageRepository' id='140288778389648'>
mock_dom_orchestrator_service = <AsyncMock spec='DomOrchestratorService' id='140288778395024'>

    @pytest.mark.asyncio
    async def test_stream_chat_response_success(
        override_get_current_user,
        override_get_chat_session_repository,
        override_get_chat_message_repository,
        override_get_dom_orchestrator_service,
        mock_current_user,
        mock_chat_session_repo,
        mock_chat_message_repo,
        mock_dom_orchestrator_service
    ):
        """
        チャット応答ストリーミングAPIの成功ケースをテストします (research_mode=False)。
        """
        session_id = uuid4()
        # Mock for existing session check
        mock_chat_session_repo.get.return_value = ChatSessionResponse(
            id=session_id, user_id=mock_current_user.id, tenant_id=mock_current_user.tenant_id, title="Existing Session", is_active=True, created_at=datetime.now(), updated_at=datetime.now()
        )
        # Mock for last user message
        mock_chat_message_repo.get_by_session_id.return_value = [
            ChatMessageResponse(id=uuid4(), session_id=session_id, role="user", content="Test prompt", created_at=datetime.now(), updated_at=datetime.now())
        ]
    
        # Mock for DomOrchestratorService streaming response (IC-5 light format)
        async def mock_orchestrator_stream():
            yield "**Decision**\nTest Decision.\n\n"
            yield "**Why**\nTest Why.\n\n"
            yield "**Next 3 Actions**\nTest Action 1, Test Action 2, Test Action 3.\n\n"
        mock_dom_orchestrator_service.process_chat_message.return_value = mock_orchestrator_stream()
    
        # Mock for assistant message saving
        mock_chat_message_repo.create.return_value = ChatMessageResponse(
            id=uuid4(), session_id=session_id, role="assistant", content="Formatted response", created_at=datetime.now(), updated_at=datetime.now()
        )
    
        response = client.get(f"/api/v1/chat/stream/{session_id}?research_mode=false") # research_mode=falseを明示的に渡す
        assert response.status_code == 200
        assert response.headers["content-type"].startswith("text/event-stream")
    
        full_response_content = ""
        for chunk in response.iter_bytes():
            full_response_content += chunk.decode("utf-8")
    
        expected_stream_parts = [
            "**Decision**\nTest Decision.\n\n",
            "**Why**\nTest Why.\n\n",
            "**Next 3 Actions**\nTest Action 1, Test Action 2, Test Action 3.\n\n",
            "[STREAM_END]"
        ]
        expected_stream = "".join(expected_stream_parts)
    
        assert full_response_content == expected_stream
    
        mock_chat_session_repo.get.assert_awaited_once_with(session_id)
        mock_chat_message_repo.get_by_session_id.assert_awaited_once_with(session_id)
>       mock_dom_orchestrator_service.process_chat_message.assert_awaited_once_with("Test prompt", str(session_id), False) # Falseを検証
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app/tests/test_endpoints_chat.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.process_chat_message' id='140289965010400'>
name = 'assert_awaited_once_with'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
            raise AttributeError(name)
        if not self._mock_unsafe and (not self._mock_methods or name not in self._mock_methods):
            if name.startswith(('assert', 'assret', 'asert', 'aseert', 'assrt')) or name in _ATTRIB_DENY_LIST:
>               raise AttributeError(
                    f"{name!r} is not a valid assertion. Use a spec "
                    f"for the mock if {name!r} is meant to be an attribute.")
E               AttributeError: 'assert_awaited_once_with' is not a valid assertion. Use a spec for the mock if 'assert_awaited_once_with' is meant to be an attribute.. Did you mean: 'assert_called_once_with'?

/usr/lib/python3.12/unittest/mock.py:663: AttributeError
__________________ test_stream_chat_response_research_mode_on __________________

override_get_current_user = None, override_get_chat_session_repository = None
override_get_chat_message_repository = None
override_get_dom_orchestrator_service = None
mock_current_user = AuthenticatedUser(id=UUID('2ac10247-bbfd-466a-b999-1a2bd27bc03e'), tenant_id=UUID('5725befc-0ad1-4a6c-aa1b-ab3041d58c6a'), email='test@example.com', is_active=True, is_admin=False)
mock_chat_session_repo = <AsyncMock spec='ChatSessionRepository' id='140288776010832'>
mock_chat_message_repo = <AsyncMock spec='ChatMessageRepository' id='140288776003440'>
mock_dom_orchestrator_service = <AsyncMock spec='DomOrchestratorService' id='140288776002336'>

    @pytest.mark.asyncio
    async def test_stream_chat_response_research_mode_on(
        override_get_current_user,
        override_get_chat_session_repository,
        override_get_chat_message_repository,
        override_get_dom_orchestrator_service,
        mock_current_user,
        mock_chat_session_repo,
        mock_chat_message_repo,
        mock_dom_orchestrator_service
    ):
        """
        チャット応答ストリーミングAPIの成功ケースをテストします (research_mode=True)。
        """
        session_id = uuid4()
        # Mock for existing session check
        mock_chat_session_repo.get.return_value = ChatSessionResponse(
            id=session_id, user_id=mock_current_user.id, tenant_id=mock_current_user.tenant_id, title="Existing Session", is_active=True, created_at=datetime.now(), updated_at=datetime.now()
        )
        # Mock for last user message
        mock_chat_message_repo.get_by_session_id.return_value = [
            ChatMessageResponse(id=uuid4(), session_id=session_id, role="user", content="Research prompt", created_at=datetime.now(), updated_at=datetime.now())
        ]
    
        # Mock for DomOrchestratorService streaming response (IC-5 light format)
        async def mock_orchestrator_stream():
            yield "**Decision**\nResearch Decision.\n\n"
            yield "**Why**\nResearch Why.\n\n"
            yield "**Next 3 Actions**\nResearch Action 1, Research Action 2, Research Action 3.\n\n"
        mock_dom_orchestrator_service.process_chat_message.return_value = mock_orchestrator_stream()
    
        # Mock for assistant message saving
        mock_chat_message_repo.create.return_value = ChatMessageResponse(
            id=uuid4(), session_id=session_id, role="assistant", content="Formatted research response", created_at=datetime.now(), updated_at=datetime.now()
        )
    
        response = client.get(f"/api/v1/chat/stream/{session_id}?research_mode=true") # research_mode=trueを渡す
        assert response.status_code == 200
        assert response.headers["content-type"].startswith("text/event-stream")
    
        full_response_content = ""
        for chunk in response.iter_bytes():
            full_response_content += chunk.decode("utf-8")
    
        expected_stream_parts = [
            "**Decision**\nResearch Decision.\n\n",
            "**Why**\nResearch Why.\n\n",
            "**Next 3 Actions**\nResearch Action 1, Research Action 2, Research Action 3.\n\n",
            "[STREAM_END]"
        ]
        expected_stream = "".join(expected_stream_parts)
    
        assert full_response_content == expected_stream
    
        mock_chat_session_repo.get.assert_awaited_once_with(session_id)
        mock_chat_message_repo.get_by_session_id.assert_awaited_once_with(session_id)
>       mock_dom_orchestrator_service.process_chat_message.assert_awaited_once_with("Research prompt", str(session_id), True) # Trueを検証
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app/tests/test_endpoints_chat.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.process_chat_message' id='140288778638816'>
name = 'assert_awaited_once_with'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
            raise AttributeError(name)
        if not self._mock_unsafe and (not self._mock_methods or name not in self._mock_methods):
            if name.startswith(('assert', 'assret', 'asert', 'aseert', 'assrt')) or name in _ATTRIB_DENY_LIST:
>               raise AttributeError(
                    f"{name!r} is not a valid assertion. Use a spec "
                    f"for the mock if {name!r} is meant to be an attribute.")
E               AttributeError: 'assert_awaited_once_with' is not a valid assertion. Use a spec for the mock if 'assert_awaited_once_with' is meant to be an attribute.. Did you mean: 'assert_called_once_with'?

/usr/lib/python3.12/unittest/mock.py:663: AttributeError
________________ test_stream_chat_response_unauthorized_session ________________

override_get_current_user = None, override_get_chat_session_repository = None
mock_current_user = AuthenticatedUser(id=UUID('4053cdea-fbcd-4041-be51-eaaddde1fc76'), tenant_id=UUID('fbcff47b-d98a-4a05-9fdf-b53e3e1c9cdb'), email='test@example.com', is_active=True, is_admin=False)
mock_chat_session_repo = <AsyncMock spec='ChatSessionRepository' id='140288778261168'>

    @pytest.mark.asyncio
    async def test_stream_chat_response_unauthorized_session(
        override_get_current_user,
        override_get_chat_session_repository,
        mock_current_user,
        mock_chat_session_repo
    ):
        """
        チャット応答ストリーミングAPIのセッション権限なしケースをテストします。
        """
        session_id = uuid4()
        # Mock for existing session check (user_id mismatch)
        mock_chat_session_repo.get.return_value = ChatSessionResponse(
            id=session_id, user_id=uuid4(), tenant_id=mock_current_user.tenant_id, title="Other User's Session", is_active=True, created_at=datetime.now(), updated_at=datetime.now()
        )
    
>       response = client.get(f"/api/v1/chat/stream/{session_id}")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app/tests/test_endpoints_chat.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/starlette/testclient.py:465: in get
    return super().get(
.venv/lib/python3.12/site-packages/httpx/_client.py:1066: in get
    return self.request(
.venv/lib/python3.12/site-packages/starlette/testclient.py:437: in request
    return super().request(
.venv/lib/python3.12/site-packages/httpx/_client.py:837: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/httpx/_client.py:926: in send
    response = self._send_handling_auth(
.venv/lib/python3.12/site-packages/httpx/_client.py:954: in _send_handling_auth
    response = self._send_handling_redirects(
.venv/lib/python3.12/site-packages/httpx/_client.py:991: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/httpx/_client.py:1027: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/starlette/testclient.py:340: in handle_request
    raise exc
.venv/lib/python3.12/site-packages/starlette/testclient.py:337: in handle_request
    portal.call(self.app, scope, receive, send)
.venv/lib/python3.12/site-packages/anyio/from_thread.py:326: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
.venv/lib/python3.12/site-packages/anyio/from_thread.py:257: in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
.venv/lib/python3.12/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
.venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.12/site-packages/starlette/routing.py:714: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/routing.py:734: in app
    await route.handle(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.12/site-packages/starlette/routing.py:73: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/fastapi/routing.py:291: in app
    solved_result = await solve_dependencies(
.venv/lib/python3.12/site-packages/fastapi/dependencies/utils.py:615: in solve_dependencies
    solved_result = await solve_dependencies(
.venv/lib/python3.12/site-packages/fastapi/dependencies/utils.py:640: in solve_dependencies
    solved = await run_in_threadpool(call, **solved_result.values)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/starlette/concurrency.py:37: in run_in_threadpool
    return await anyio.to_thread.run_sync(func)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/anyio/to_thread.py:61: in run_sync
    return await get_async_backend().run_sync_in_worker_thread(
.venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:2525: in run_sync_in_worker_thread
    return await future
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:986: in run
    result = context.run(func, *args)
             ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def get_answer_composer_service() -> AnswerComposerService:
        """
        AnswerComposerServiceの依存性注入を提供します。
        """
>       return AnswerComposerService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: AnswerComposerService.__init__() takes 0 positional arguments but 1 was given

app/dependencies.py:164: TypeError
_________________________ test_submit_feedback_success _________________________

override_get_current_user = None, override_get_feedback_service = None
mock_current_user = AuthenticatedUser(id=UUID('021ec6cc-3c4d-48cc-85b1-912219e86c17'), tenant_id=UUID('5fbbb3e0-68bd-4098-9abf-0d1263a259d9'), email='test@example.com', is_active=True, is_admin=False)
mock_feedback_service = <AsyncMock spec='FeedbackService' id='140288778637808'>

    @pytest.mark.asyncio
    async def test_submit_feedback_success(
        override_get_current_user,
        override_get_feedback_service,
        mock_current_user,
        mock_feedback_service
    ):
        """
        フィードバック送信APIの成功ケースをテストします。
        """
        feedback_id = uuid4()
        session_id = uuid4()
        message_id = uuid4()
        feedback_data = FeedbackCreate(
            session_id=session_id,
            message_id=message_id,
            rating=1,
            comment="Great response!"
        )
        mock_feedback_service.create_feedback.return_value = FeedbackResponse(
            id=feedback_id,
            tenant_id=mock_current_user.tenant_id,
            user_id=mock_current_user.id,
            session_id=session_id,
            message_id=message_id,
            rating=feedback_data.rating,
            comment=feedback_data.comment,
            created_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc)
        )
    
>       response = client.post("/api/v1/feedback", json=feedback_data.model_dump())
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app/tests/test_endpoints_feedback.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/starlette/testclient.py:538: in post
    return super().post(
.venv/lib/python3.12/site-packages/httpx/_client.py:1157: in post
    return self.request(
.venv/lib/python3.12/site-packages/starlette/testclient.py:437: in request
    return super().request(
.venv/lib/python3.12/site-packages/httpx/_client.py:824: in request
    request = self.build_request(
.venv/lib/python3.12/site-packages/httpx/_client.py:358: in build_request
    return Request(
.venv/lib/python3.12/site-packages/httpx/_models.py:342: in __init__
    headers, stream = encode_request(
.venv/lib/python3.12/site-packages/httpx/_content.py:214: in encode_request
    return encode_json(json)
           ^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/httpx/_content.py:177: in encode_json
    body = json_dumps(json).encode("utf-8")
           ^^^^^^^^^^^^^^^^
/usr/lib/python3.12/json/__init__.py:231: in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/json/encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/json/encoder.py:258: in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x7f97cfa3e510>
o = UUID('a1d18378-df5b-4e3e-9ca8-cd9122194dd3')

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type UUID is not JSON serializable

/usr/lib/python3.12/json/encoder.py:180: TypeError
____________________ test_get_feedback_for_session_success _____________________

override_get_current_user = None, override_get_feedback_service = None
mock_current_user = AuthenticatedUser(id=UUID('145396bc-c0f0-44ee-a9cd-5ae739e0611c'), tenant_id=UUID('1ac0518f-5897-4b72-b7e5-7177c8539c5e'), email='test@example.com', is_active=True, is_admin=False)
mock_feedback_service = <AsyncMock spec='FeedbackService' id='140288776010880'>

    @pytest.mark.asyncio
    async def test_get_feedback_for_session_success(
        override_get_current_user,
        override_get_feedback_service,
        mock_current_user,
        mock_feedback_service
    ):
        """
        セッションIDによるフィードバック取得の成功ケースをテストします。
        """
        session_id = uuid4()
        feedback_1 = FeedbackResponse(
            id=uuid4(), tenant_id=mock_current_user.tenant_id, user_id=mock_current_user.id, session_id=session_id,
            rating=1, comment="Good", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc)
        )
        feedback_2 = FeedbackResponse(
            id=uuid4(), tenant_id=mock_current_user.tenant_id, user_id=mock_current_user.id, session_id=session_id,
            rating=-1, comment="Bad", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc)
        )
        mock_feedback_service.get_feedback_by_session_id.return_value = [feedback_1, feedback_2]
    
        response = client.get(f"/api/v1/feedback/{session_id}")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app/tests/test_endpoints_feedback.py:108: AssertionError
____________________ test_get_feedback_for_message_success _____________________

override_get_current_user = None, override_get_feedback_service = None
mock_current_user = AuthenticatedUser(id=UUID('a1797e7f-79b5-4093-89b5-72e5b94f52b3'), tenant_id=UUID('9a4c15d1-f3bb-4aee-afa0-d711d3fcee11'), email='test@example.com', is_active=True, is_admin=False)
mock_feedback_service = <AsyncMock spec='FeedbackService' id='140288776006944'>

    @pytest.mark.asyncio
    async def test_get_feedback_for_message_success(
        override_get_current_user,
        override_get_feedback_service,
        mock_current_user,
        mock_feedback_service
    ):
        """
        メッセージIDによるフィードバック取得の成功ケースをテストします。
        """
        message_id = uuid4()
        feedback = FeedbackResponse(
            id=uuid4(), tenant_id=mock_current_user.tenant_id, user_id=mock_current_user.id, session_id=uuid4(),
            message_id=message_id, rating=1, comment="Very helpful", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc)
        )
        mock_feedback_service.get_feedback_by_message_id.return_value = feedback
    
        response = client.get(f"/api/v1/feedback/message/{message_id}")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app/tests/test_endpoints_feedback.py:131: AssertionError
___________________ test_get_feedback_for_message_not_found ____________________

override_get_current_user = None, override_get_feedback_service = None
mock_feedback_service = <AsyncMock spec='FeedbackService' id='140288778392816'>

    @pytest.mark.asyncio
    async def test_get_feedback_for_message_not_found(
        override_get_current_user,
        override_get_feedback_service,
        mock_feedback_service
    ):
        """
        メッセージIDによるフィードバックが見つからない場合のテスト。
        """
        message_id = uuid4()
        mock_feedback_service.get_feedback_by_message_id.return_value = None
    
        response = client.get(f"/api/v1/feedback/message/{message_id}")
>       assert response.status_code == 200 # Optional[FeedbackResponse]なのでNoneを返す場合は200
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app/tests/test_endpoints_feedback.py:148: AssertionError
__________________ test_get_feedback_for_message_unauthorized __________________

override_get_current_user = None, override_get_feedback_service = None
mock_feedback_service = <AsyncMock spec='FeedbackService' id='140288778398576'>

    @pytest.mark.asyncio
    async def test_get_feedback_for_message_unauthorized(
        override_get_current_user,
        override_get_feedback_service,
        mock_feedback_service
    ):
        """
        メッセージIDによるフィードバック取得で権限がない場合のテスト。
        """
        message_id = uuid4()
        # 別のテナントのフィードバックを返すようにモック
        unauthorized_feedback = FeedbackResponse(
            id=uuid4(), tenant_id=uuid4(), user_id=uuid4(), session_id=uuid4(),
            message_id=message_id, rating=1, comment="Not yours", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc)
        )
        mock_feedback_service.get_feedback_by_message_id.return_value = unauthorized_feedback
    
        response = client.get(f"/api/v1/feedback/message/{message_id}")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app/tests/test_endpoints_feedback.py:170: AssertionError
_____________________ test_upload_file_global_rag_success ______________________

override_get_current_user = None, override_get_file_service = None
override_get_knowledge_document_repository = None
override_get_rag_service = None
mock_current_user = AuthenticatedUser(id=UUID('557e0c78-82bd-41be-88a0-6f0a4e8c1d5f'), tenant_id=UUID('45f68c97-2e8f-4dd9-99fc-57bce27ff481'), email='test@example.com', is_active=True, is_admin=False)
mock_file_service = <AsyncMock spec='FileService' id='140288778262176'>
mock_knowledge_document_repository = <AsyncMock spec='KnowledgeDocumentRepository' id='140288778264816'>
mock_rag_service = <AsyncMock spec='RagService' id='140288776006464'>

    @pytest.mark.asyncio
    async def test_upload_file_global_rag_success(
        override_get_current_user,
        override_get_file_service,
        override_get_knowledge_document_repository,
        override_get_rag_service,
        mock_current_user,
        mock_file_service,
        mock_knowledge_document_repository,
        mock_rag_service
    ):
        """
        ファイルをアップロードし、グローバルRAGに登録する成功ケースをテストします。
        """
        file_content = b"This is a test document."
        mock_file = BytesIO(file_content)
        file_name = "test.txt"
        file_id = uuid4()
    
>       mock_file_service.save_file.return_value = MagicMock(
                                                   ^^^^^^^^^
            id=file_id,
            tenant_id=mock_current_user.tenant_id,
            file_name=file_name,
            file_path="/path/to/test.txt",
            file_type="text/plain",
            file_size=str(len(file_content)),
            uploaded_by_user_id=mock_current_user.id,
            is_active=True
        )
E       NameError: name 'MagicMock' is not defined

app/tests/test_endpoints_files.py:86: NameError
____________________ test_upload_file_ephemeral_rag_success ____________________

override_get_current_user = None, override_get_file_service = None
override_get_knowledge_document_repository = None
override_get_rag_service = None
mock_current_user = AuthenticatedUser(id=UUID('65aa775f-dd07-471a-8b97-dfaafe7f78b3'), tenant_id=UUID('e4843489-97cc-4ea0-ae39-2d8b12881ba9'), email='test@example.com', is_active=True, is_admin=False)
mock_file_service = <AsyncMock spec='FileService' id='140288776008336'>
mock_knowledge_document_repository = <AsyncMock spec='KnowledgeDocumentRepository' id='140288776000320'>
mock_rag_service = <AsyncMock spec='RagService' id='140288776006320'>

    @pytest.mark.asyncio
    async def test_upload_file_ephemeral_rag_success(
        override_get_current_user,
        override_get_file_service,
        override_get_knowledge_document_repository,
        override_get_rag_service,
        mock_current_user,
        mock_file_service,
        mock_knowledge_document_repository,
        mock_rag_service
    ):
        """
        ファイルをアップロードし、Ephemeral RAGに登録する成功ケースをテストします。
        """
        file_content = b"This is a session-specific document."
        mock_file = BytesIO(file_content)
        file_name = "session_doc.md"
        file_id = uuid4()
        session_id = uuid4()
    
>       mock_file_service.save_file.return_value = MagicMock(
                                                   ^^^^^^^^^
            id=file_id,
            tenant_id=mock_current_user.tenant_id,
            file_name=file_name,
            file_path="/path/to/session_doc.md",
            file_type="text/markdown",
            file_size=str(len(file_content)),
            uploaded_by_user_id=mock_current_user.id,
            is_active=True
        )
E       NameError: name 'MagicMock' is not defined

app/tests/test_endpoints_files.py:144: NameError
_________________________ test_upload_file_no_filename _________________________

override_get_current_user = None, override_get_file_service = None

    @pytest.mark.asyncio
    async def test_upload_file_no_filename(
        override_get_current_user,
        override_get_file_service,
    ):
        """
        ファイル名がない場合のアップロード失敗ケースをテストします。
        """
        response = client.post(
            "/api/v1/files/upload",
            files={"file": (None, BytesIO(b"content"), "text/plain")}
        )
        assert response.status_code == 400
>       assert "No file name provided." in response.json()["detail"]
E       AssertionError: assert 'No file name provided.' in 'There was an error parsing the body'

app/tests/test_endpoints_files.py:197: AssertionError
______________________ test_upload_file_validation_error _______________________

override_get_current_user = None, override_get_file_service = None

    @pytest.mark.asyncio
    async def test_upload_file_validation_error(
        override_get_current_user,
        override_get_file_service,
    ):
        """
        ファイルバリデーションエラー時のアップロード失敗ケースをテストします。
        """
>       mock_file_service.save_file.side_effect = HTTPException(
                                                  ^^^^^^^^^^^^^
            status_code=413, detail="File size exceeds the limit."
        )
E       NameError: name 'HTTPException' is not defined

app/tests/test_endpoints_files.py:208: NameError
_______________________ test_rag_service_initialization ________________________

mock_tenant_id = UUID('c88dd28d-6610-47e5-bfa6-3e443ce8e7f9')
mock_llm_client = <AsyncMock spec='MockLLMClient' id='140288777391952'>
mock_pgvector = <MagicMock name='PGVector' spec='PGVector' id='140288776083008'>
mock_embeddings = <MagicMock name='GoogleGenerativeAIEmbeddings' spec='GoogleGenerativeAIEmbeddings' id='140288749785200'>
mock_chat_google_generative_ai = <MagicMock name='ChatGoogleGenerativeAI' spec='ChatGoogleGenerativeAI' id='140288748598288'>

    @pytest.mark.asyncio
    async def test_rag_service_initialization(
        mock_tenant_id,
        mock_llm_client,
        mock_pgvector,
        mock_embeddings,
        mock_chat_google_generative_ai
    ):
        """RagServiceが正しく初期化されることをテスト"""
>       service = RagService(tenant_id=mock_tenant_id, llm_client=mock_llm_client)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app/tests/test_rag_service.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/rag_service.py:29: in __init__
    self.global_vectorstore = PGVector(
/usr/lib/python3.12/unittest/mock.py:1132: in __call__
    self._mock_check_sig(*args, **kwargs)
/usr/lib/python3.12/unittest/mock.py:131: in checksig
    sig.bind(*args, **kwargs)
/usr/lib/python3.12/inspect.py:3242: in bind
    return self._bind(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Signature (embeddings: 'Embeddings', *, connection: 'Union[None, DBConnection, Engine, AsyncEngine, str]' = None, emb...t[str, Any]]' = None, use_jsonb: 'bool' = True, create_extension: 'bool' = True, async_mode: 'bool' = False) -> 'None'>
args = ()
kwargs = {'connection_string': 'postgresql+asyncpg://user:password@localhost:5432/dom_gateway'}

    def _bind(self, args, kwargs, *, partial=False):
        """Private method. Don't use directly."""
    
        arguments = {}
    
        parameters = iter(self.parameters.values())
        parameters_ex = ()
        arg_vals = iter(args)
    
        while True:
            # Let's iterate through the positional arguments and corresponding
            # parameters
            try:
                arg_val = next(arg_vals)
            except StopIteration:
                # No more positional arguments
                try:
                    param = next(parameters)
                except StopIteration:
                    # No more parameters. That's it. Just need to check that
                    # we have no `kwargs` after this while loop
                    break
                else:
                    if param.kind == _VAR_POSITIONAL:
                        # That's OK, just empty *args.  Let's start parsing
                        # kwargs
                        break
                    elif param.name in kwargs:
                        if param.kind == _POSITIONAL_ONLY:
                            msg = '{arg!r} parameter is positional only, ' \
                                  'but was passed as a keyword'
                            msg = msg.format(arg=param.name)
                            raise TypeError(msg) from None
                        parameters_ex = (param,)
                        break
                    elif (param.kind == _VAR_KEYWORD or
                                                param.default is not _empty):
                        # That's fine too - we have a default value for this
                        # parameter.  So, lets start parsing `kwargs`, starting
                        # with the current parameter
                        parameters_ex = (param,)
                        break
                    else:
                        # No default, not VAR_KEYWORD, not VAR_POSITIONAL,
                        # not in `kwargs`
                        if partial:
                            parameters_ex = (param,)
                            break
                        else:
                            if param.kind == _KEYWORD_ONLY:
                                argtype = ' keyword-only'
                            else:
                                argtype = ''
                            msg = 'missing a required{argtype} argument: {arg!r}'
                            msg = msg.format(arg=param.name, argtype=argtype)
                            raise TypeError(msg) from None
            else:
                # We have a positional argument to process
                try:
                    param = next(parameters)
                except StopIteration:
                    raise TypeError('too many positional arguments') from None
                else:
                    if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
                        # Looks like we have no parameter for this positional
                        # argument
                        raise TypeError(
                            'too many positional arguments') from None
    
                    if param.kind == _VAR_POSITIONAL:
                        # We have an '*args'-like argument, let's fill it with
                        # all positional arguments we have left and move on to
                        # the next phase
                        values = [arg_val]
                        values.extend(arg_vals)
                        arguments[param.name] = tuple(values)
                        break
    
                    if param.name in kwargs and param.kind != _POSITIONAL_ONLY:
                        raise TypeError(
                            'multiple values for argument {arg!r}'.format(
                                arg=param.name)) from None
    
                    arguments[param.name] = arg_val
    
        # Now, we iterate through the remaining parameters to process
        # keyword arguments
        kwargs_param = None
        for param in itertools.chain(parameters_ex, parameters):
            if param.kind == _VAR_KEYWORD:
                # Memorize that we have a '**kwargs'-like parameter
                kwargs_param = param
                continue
    
            if param.kind == _VAR_POSITIONAL:
                # Named arguments don't refer to '*args'-like parameters.
                # We only arrive here if the positional arguments ended
                # before reaching the last parameter before *args.
                continue
    
            param_name = param.name
            try:
                arg_val = kwargs.pop(param_name)
            except KeyError:
                # We have no value for this parameter.  It's fine though,
                # if it has a default value, or it is an '*args'-like
                # parameter, left alone by the processing of positional
                # arguments.
                if (not partial and param.kind != _VAR_POSITIONAL and
                                                    param.default is _empty):
                    raise TypeError('missing a required argument: {arg!r}'. \
                                    format(arg=param_name)) from None
    
            else:
                if param.kind == _POSITIONAL_ONLY:
                    # This should never happen in case of a properly built
                    # Signature object (but let's have this check here
                    # to ensure correct behaviour just in case)
                    raise TypeError('{arg!r} parameter is positional only, '
                                    'but was passed as a keyword'. \
                                    format(arg=param.name))
    
                arguments[param_name] = arg_val
    
        if kwargs:
            if kwargs_param is not None:
                # Process our '**kwargs'-like parameter
                arguments[kwargs_param.name] = kwargs
            else:
>               raise TypeError(
                    'got an unexpected keyword argument {arg!r}'.format(
                        arg=next(iter(kwargs))))
E               TypeError: got an unexpected keyword argument 'connection_string'

/usr/lib/python3.12/inspect.py:3231: TypeError
__________________ test_base_repository_get_no_tenant_filter ___________________

base_repo_no_tenant = <app.repositories.base.BaseRepository object at 0x7f97847c6060>
mock_session = <AsyncMock spec='AsyncSession' id='140288739533088'>

    @pytest.mark.asyncio
    async def test_base_repository_get_no_tenant_filter(base_repo_no_tenant, mock_session):
        """BaseRepository.get() (tenant_idなし)のテスト"""
        test_id = uuid4()
        mock_tenant = Tenant(id=test_id, name="Test Tenant")
        mock_session.execute.return_value.scalar_one_or_none.return_value = mock_tenant
    
        tenant = await base_repo_no_tenant.get(test_id)
>       assert tenant == mock_tenant
E       AssertionError: assert <coroutine object AsyncMockMixin._execute_mock_call at 0x7f9786c3b040> == <Tenant(id='dc7d4beb-5147-4cdb-ad94-3324de20ab8f', name='Test Tenant')>

app/tests/test_repositories.py:53: AssertionError
_________________ test_base_repository_get_with_tenant_filter __________________

base_repo_with_tenant = <app.repositories.base.BaseRepository object at 0x7f9784839820>
mock_session = <AsyncMock spec='AsyncSession' id='140288740002320'>

    @pytest.mark.asyncio
    async def test_base_repository_get_with_tenant_filter(base_repo_with_tenant, mock_session):
        """BaseRepository.get() (tenant_idあり)のテスト"""
        test_id = uuid4()
        mock_user = User(id=test_id, tenant_id=base_repo_with_tenant.tenant_id, email="a@b.com", hashed_password="pw")
        mock_session.execute.return_value.scalar_one_or_none.return_value = mock_user
    
        user = await base_repo_with_tenant.get(test_id)
>       assert user == mock_user
E       AssertionError: assert <coroutine object AsyncMockMixin._execute_mock_call at 0x7f9786c3b640> == <User(id='34e58e39-d7dd-45f6-9a84-f5c3a1ad5826', email='a@b.com', tenant_id='dee44bbe-e523-44bb-9326-57281456f839')>

app/tests/test_repositories.py:65: AssertionError
______________________ test_tenant_repository_get_by_name ______________________

tenant_repo = <app.repositories.tenant.TenantRepository object at 0x7f9784824860>
mock_session = <AsyncMock spec='AsyncSession' id='140288739920112'>

    @pytest.mark.asyncio
    async def test_tenant_repository_get_by_name(tenant_repo, mock_session):
        """TenantRepository.get_by_name()のテスト (tenant_idフィルタなし)"""
        test_name = "Unique Tenant"
        mock_tenant = Tenant(id=uuid4(), name=test_name)
        mock_session.execute.return_value.scalar_one_or_none.return_value = mock_tenant
    
        tenant = await tenant_repo.get_by_name(test_name)
>       assert tenant == mock_tenant
E       AssertionError: assert <coroutine object AsyncMockMixin._execute_mock_call at 0x7f97848cc440> == <Tenant(id='67a76580-630b-417a-8f2a-dcac812919d6', name='Unique Tenant')>

app/tests/test_repositories.py:98: AssertionError
________________ test_user_repository_get_by_email_with_tenant _________________

user_repo_with_tenant = <app.repositories.user.UserRepository object at 0x7f9784824cb0>
mock_session = <AsyncMock spec='AsyncSession' id='140288739927360'>

    @pytest.mark.asyncio
    async def test_user_repository_get_by_email_with_tenant(user_repo_with_tenant, mock_session):
        """UserRepository.get_by_email() (tenant_idあり)のテスト"""
        test_email = "test@example.com"
        mock_user = User(id=uuid4(), tenant_id=user_repo_with_tenant.tenant_id, email=test_email, hashed_password="pw")
        mock_session.execute.return_value.scalar_one_or_none.return_value = mock_user
    
        user = await user_repo_with_tenant.get_by_email(test_email)
>       assert user == mock_user
/home/masahiro/work/dom-enterprise-gateway/backend/.venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:33: RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited
  gc.collect()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
E       AssertionError: assert <coroutine object AsyncMockMixin._execute_mock_call at 0x7f97848ccd40> == <User(id='eaf86956-004d-40e3-a2da-7d60d7ab3c76', email='test@example.com', tenant_id='81f59cd1-d9c7-4a7c-9d90-576a6b0e3ff1')>

app/tests/test_repositories.py:112: AssertionError
_________________ test_user_repository_get_by_email_no_tenant __________________

user_repo_no_tenant = <app.repositories.user.UserRepository object at 0x7f9784864770>
mock_session = <AsyncMock spec='AsyncSession' id='140288740182016'>

    @pytest.mark.asyncio
    async def test_user_repository_get_by_email_no_tenant(user_repo_no_tenant, mock_session):
        """UserRepository.get_by_email() (tenant_idなし)のテスト"""
        test_email = "test@example.com"
        mock_user = User(id=uuid4(), tenant_id=uuid4(), email=test_email, hashed_password="pw")
        mock_session.execute.return_value.scalar_one_or_none.return_value = mock_user
    
        user = await user_repo_no_tenant.get_by_email(test_email)
>       assert user == mock_user
E       AssertionError: assert <coroutine object AsyncMockMixin._execute_mock_call at 0x7f97848cd740> == <User(id='77cb818f-02da-409b-9c13-bbf03a9f5d14', email='test@example.com', tenant_id='b0e0d5f2-5028-4a0e-9b82-69c6f0f4e3f6')>

app/tests/test_repositories.py:126: AssertionError
=============================== warnings summary ===============================
app/schemas/auth.py:4
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/auth.py:4: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class AuthenticatedUser(BaseModel):

app/schemas/chat.py:15
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/chat.py:15: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatMessageResponse(BaseModel):

app/schemas/chat.py:36
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/chat.py:36: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatSessionResponse(BaseModel):

app/schemas/file.py:5
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/file.py:5: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class FileUploadResponse(BaseModel):

app/schemas/feedback.py:16
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/feedback.py:16: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class FeedbackResponse(BaseModel):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED app/tests/test_dom_orchestrator_service.py::test_process_chat_message_ic5_light_streaming
FAILED app/tests/test_endpoints_auth.py::test_read_current_user_inactive_user
FAILED app/tests/test_endpoints_chat.py::test_stream_chat_response_success - ...
FAILED app/tests/test_endpoints_chat.py::test_stream_chat_response_research_mode_on
FAILED app/tests/test_endpoints_chat.py::test_stream_chat_response_unauthorized_session
FAILED app/tests/test_endpoints_feedback.py::test_submit_feedback_success - T...
FAILED app/tests/test_endpoints_feedback.py::test_get_feedback_for_session_success
FAILED app/tests/test_endpoints_feedback.py::test_get_feedback_for_message_success
FAILED app/tests/test_endpoints_feedback.py::test_get_feedback_for_message_not_found
FAILED app/tests/test_endpoints_feedback.py::test_get_feedback_for_message_unauthorized
FAILED app/tests/test_endpoints_files.py::test_upload_file_global_rag_success
FAILED app/tests/test_endpoints_files.py::test_upload_file_ephemeral_rag_success
FAILED app/tests/test_endpoints_files.py::test_upload_file_no_filename - Asse...
FAILED app/tests/test_endpoints_files.py::test_upload_file_validation_error
FAILED app/tests/test_rag_service.py::test_rag_service_initialization - TypeE...
FAILED app/tests/test_repositories.py::test_base_repository_get_no_tenant_filter
FAILED app/tests/test_repositories.py::test_base_repository_get_with_tenant_filter
FAILED app/tests/test_repositories.py::test_tenant_repository_get_by_name - A...
FAILED app/tests/test_repositories.py::test_user_repository_get_by_email_with_tenant
FAILED app/tests/test_repositories.py::test_user_repository_get_by_email_no_tenant
ERROR app/tests/test_rag_service.py::test_query_rag - TypeError: got an unexp...
ERROR app/tests/test_rag_service.py::test_add_documents - TypeError: got an u...
ERROR app/tests/test_rag_service.py::test_stream_rag_response - TypeError: go...
============= 20 failed, 31 passed, 5 warnings, 3 errors in 2.26s ==============
sys:1: RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited
