============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/masahiro/work/dom-enterprise-gateway/backend
configfile: pyproject.toml
plugins: langsmith-0.4.55, anyio-4.12.0, asyncio-0.23.8
asyncio: mode=Mode.STRICT
collected 54 items

app/tests/test_auth_service.py ......                                    [ 11%]
app/tests/test_chat_service.py ...                                       [ 16%]
app/tests/test_dom_orchestrator_service.py ...                           [ 22%]
app/tests/test_endpoints_admin.py ...                                    [ 27%]
app/tests/test_endpoints_auth.py .....                                   [ 37%]
app/tests/test_endpoints_chat.py ......F                                 [ 50%]
app/tests/test_endpoints_feedback.py FFFFF                               [ 59%]
app/tests/test_endpoints_files.py FFFF                                   [ 66%]
app/tests/test_main.py .                                                 [ 68%]
app/tests/test_memory_service.py .......                                 [ 81%]
app/tests/test_rag_service.py FEEE                                       [ 88%]
app/tests/test_repositories.py ....F.                                    [100%]

==================================== ERRORS ====================================
_______________________ ERROR at setup of test_query_rag _______________________

mock_tenant_id = UUID('d072c074-660f-4571-a9b4-ec24b327bc91')
mock_llm_client = <AsyncMock spec='MockLLMClient' id='139819053929664'>
mock_pgvector = <MagicMock name='PGVector' spec='PGVector' id='139819053933600'>
mock_embeddings = <MagicMock name='GoogleGenerativeAIEmbeddings' spec='GoogleGenerativeAIEmbeddings' id='139819044634592'>
mock_chat_google_generative_ai = <MagicMock name='ChatGoogleGenerativeAI' spec='ChatGoogleGenerativeAI' id='139819040039968'>

    @pytest.fixture
    def rag_service(
        mock_tenant_id,
        mock_llm_client,
        mock_pgvector,
        mock_embeddings,
        mock_chat_google_generative_ai
    ):
        """RagServiceのフィクスチャ"""
        service = RagService(tenant_id=mock_tenant_id, llm_client=mock_llm_client)
        # 依存するオブジェクトがモックであることを確認
>       assert isinstance(service.global_vectorstore, (MagicMock, Mock))
E       AssertionError: assert False
E        +  where False = isinstance(<NonCallableMagicMock name='PGVector()' spec='PGVector' id='139819053933888'>, (<class 'unittest.mock.MagicMock'>, <class 'unittest.mock.Mock'>))
E        +    where <NonCallableMagicMock name='PGVector()' spec='PGVector' id='139819053933888'> = <app.services.rag_service.RagService object at 0x7f2a290ad520>.global_vectorstore

app/tests/test_rag_service.py:54: AssertionError
_____________________ ERROR at setup of test_add_documents _____________________

mock_tenant_id = UUID('f98153b9-26a5-4ecf-b680-9408508c31aa')
mock_llm_client = <AsyncMock spec='MockLLMClient' id='139819046803344'>
mock_pgvector = <MagicMock name='PGVector' spec='PGVector' id='139819046806992'>
mock_embeddings = <MagicMock name='GoogleGenerativeAIEmbeddings' spec='GoogleGenerativeAIEmbeddings' id='139818964695088'>
mock_chat_google_generative_ai = <MagicMock name='ChatGoogleGenerativeAI' spec='ChatGoogleGenerativeAI' id='139819051588528'>

    @pytest.fixture
    def rag_service(
        mock_tenant_id,
        mock_llm_client,
        mock_pgvector,
        mock_embeddings,
        mock_chat_google_generative_ai
    ):
        """RagServiceのフィクスチャ"""
        service = RagService(tenant_id=mock_tenant_id, llm_client=mock_llm_client)
        # 依存するオブジェクトがモックであることを確認
>       assert isinstance(service.global_vectorstore, (MagicMock, Mock))
E       AssertionError: assert False
E        +  where False = isinstance(<NonCallableMagicMock name='PGVector()' spec='PGVector' id='139819046807280'>, (<class 'unittest.mock.MagicMock'>, <class 'unittest.mock.Mock'>))
E        +    where <NonCallableMagicMock name='PGVector()' spec='PGVector' id='139819046807280'> = <app.services.rag_service.RagService object at 0x7f2a289e1550>.global_vectorstore

app/tests/test_rag_service.py:54: AssertionError
__________________ ERROR at setup of test_stream_rag_response __________________

mock_tenant_id = UUID('6dbaf8db-1592-4d35-8942-e8fc4bd2ad90')
mock_llm_client = <AsyncMock spec='MockLLMClient' id='139819038889056'>
mock_pgvector = <MagicMock name='PGVector' spec='PGVector' id='139819038892656'>
mock_embeddings = <MagicMock name='GoogleGenerativeAIEmbeddings' spec='GoogleGenerativeAIEmbeddings' id='139819046335696'>
mock_chat_google_generative_ai = <MagicMock name='ChatGoogleGenerativeAI' spec='ChatGoogleGenerativeAI' id='139819050732192'>

    @pytest.fixture
    def rag_service(
        mock_tenant_id,
        mock_llm_client,
        mock_pgvector,
        mock_embeddings,
        mock_chat_google_generative_ai
    ):
        """RagServiceのフィクスチャ"""
        service = RagService(tenant_id=mock_tenant_id, llm_client=mock_llm_client)
        # 依存するオブジェクトがモックであることを確認
>       assert isinstance(service.global_vectorstore, (MagicMock, Mock))
E       AssertionError: assert False
E        +  where False = isinstance(<NonCallableMagicMock name='PGVector()' spec='PGVector' id='139819038892944'>, (<class 'unittest.mock.MagicMock'>, <class 'unittest.mock.Mock'>))
E        +    where <NonCallableMagicMock name='PGVector()' spec='PGVector' id='139819038892944'> = <app.services.rag_service.RagService object at 0x7f2a28255400>.global_vectorstore

app/tests/test_rag_service.py:54: AssertionError
=================================== FAILURES ===================================
________________ test_stream_chat_response_unauthorized_session ________________

override_get_current_user = None, override_get_chat_session_repository = None
mock_current_user = AuthenticatedUser(id=UUID('50feb76e-6e99-49bb-b9b6-f25c4cb4434f'), tenant_id=UUID('8db3d3b6-64d4-459e-a18a-7bf9a7d5220b'), email='test@example.com', is_active=True, is_admin=False)
mock_chat_session_repo = <AsyncMock spec='ChatSessionRepository' id='139819072764672'>

    @pytest.mark.asyncio
    async def test_stream_chat_response_unauthorized_session(
        override_get_current_user,
        override_get_chat_session_repository,
        mock_current_user,
        mock_chat_session_repo
    ):
        """
        チャット応答ストリーミングAPIのセッション権限なしケースをテストします。
        """
        session_id = uuid4()
        # Mock for existing session check (user_id mismatch)
        mock_chat_session_repo.get.return_value = ChatSessionResponse(
            id=session_id, user_id=uuid4(), tenant_id=mock_current_user.tenant_id, title="Other User's Session", is_active=True, created_at=datetime.now(), updated_at=datetime.now()
        )
    
>       response = client.get(f"/api/v1/chat/stream/{session_id}")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app/tests/test_endpoints_chat.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/starlette/testclient.py:465: in get
    return super().get(
.venv/lib/python3.12/site-packages/httpx/_client.py:1066: in get
    return self.request(
.venv/lib/python3.12/site-packages/starlette/testclient.py:437: in request
    return super().request(
.venv/lib/python3.12/site-packages/httpx/_client.py:837: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/httpx/_client.py:926: in send
    response = self._send_handling_auth(
.venv/lib/python3.12/site-packages/httpx/_client.py:954: in _send_handling_auth
    response = self._send_handling_redirects(
.venv/lib/python3.12/site-packages/httpx/_client.py:991: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/httpx/_client.py:1027: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/starlette/testclient.py:340: in handle_request
    raise exc
.venv/lib/python3.12/site-packages/starlette/testclient.py:337: in handle_request
    portal.call(self.app, scope, receive, send)
.venv/lib/python3.12/site-packages/anyio/from_thread.py:326: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
.venv/lib/python3.12/site-packages/anyio/from_thread.py:257: in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
.venv/lib/python3.12/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
.venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.12/site-packages/starlette/routing.py:714: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/routing.py:734: in app
    await route.handle(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
.venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.12/site-packages/starlette/routing.py:73: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/fastapi/routing.py:291: in app
    solved_result = await solve_dependencies(
.venv/lib/python3.12/site-packages/fastapi/dependencies/utils.py:615: in solve_dependencies
    solved_result = await solve_dependencies(
.venv/lib/python3.12/site-packages/fastapi/dependencies/utils.py:640: in solve_dependencies
    solved = await run_in_threadpool(call, **solved_result.values)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/starlette/concurrency.py:37: in run_in_threadpool
    return await anyio.to_thread.run_sync(func)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/anyio/to_thread.py:61: in run_sync
    return await get_async_backend().run_sync_in_worker_thread(
.venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:2525: in run_sync_in_worker_thread
    return await future
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:986: in run
    result = context.run(func, *args)
             ^^^^^^^^^^^^^^^^^^^^^^^^
app/dependencies.py:175: in get_rag_service
    return RagService(tenant_id=current_user.tenant_id, llm_client=llm_client)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app/services/rag_service.py:26: in __init__
    self.embeddings = GoogleGenerativeAIEmbeddings(model="models/embedding-001")
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/langchain_google_genai/embeddings.py:139: in validate_environment
    self.client = build_generative_service(
.venv/lib/python3.12/site-packages/langchain_google_genai/_genai_extension.py:360: in build_generative_service
    return v1betaGenerativeServiceClient(**config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/client.py:698: in __init__
    self._transport = transport_init(
.venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/transports/grpc.py:235: in __init__
    super().__init__(
.venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/transports/base.py:105: in __init__
    credentials, _ = google.auth.default(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scopes = None, request = None, quota_project_id = None, default_scopes = ()

    def default(scopes=None, request=None, quota_project_id=None, default_scopes=None):
        """Gets the default credentials for the current environment.
    
        `Application Default Credentials`_ provides an easy way to obtain
        credentials to call Google APIs for server-to-server or local applications.
        This function acquires credentials from the environment in the following
        order:
    
        1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set
           to the path of a valid service account JSON private key file, then it is
           loaded and returned. The project ID returned is the project ID defined
           in the service account file if available (some older files do not
           contain project ID information).
    
           If the environment variable is set to the path of a valid external
           account JSON configuration file (workload identity federation), then the
           configuration file is used to determine and retrieve the external
           credentials from the current environment (AWS, Azure, etc).
           These will then be exchanged for Google access tokens via the Google STS
           endpoint.
           The project ID returned in this case is the one corresponding to the
           underlying workload identity pool resource if determinable.
    
           If the environment variable is set to the path of a valid GDCH service
           account JSON file (`Google Distributed Cloud Hosted`_), then a GDCH
           credential will be returned. The project ID returned is the project
           specified in the JSON file.
        2. If the `Google Cloud SDK`_ is installed and has application default
           credentials set they are loaded and returned.
    
           To enable application default credentials with the Cloud SDK run::
    
                gcloud auth application-default login
    
           If the Cloud SDK has an active project, the project ID is returned. The
           active project can be set using::
    
                gcloud config set project
    
        3. If the application is running in the `App Engine standard environment`_
           (first generation) then the credentials and project ID from the
           `App Identity Service`_ are used.
        4. If the application is running in `Compute Engine`_ or `Cloud Run`_ or
           the `App Engine flexible environment`_ or the `App Engine standard
           environment`_ (second generation) then the credentials and project ID
           are obtained from the `Metadata Service`_.
        5. If no credentials are found,
           :class:`~google.auth.exceptions.DefaultCredentialsError` will be raised.
    
        .. _Application Default Credentials: https://developers.google.com\
                /identity/protocols/application-default-credentials
        .. _Google Cloud SDK: https://cloud.google.com/sdk
        .. _App Engine standard environment: https://cloud.google.com/appengine
        .. _App Identity Service: https://cloud.google.com/appengine/docs/python\
                /appidentity/
        .. _Compute Engine: https://cloud.google.com/compute
        .. _App Engine flexible environment: https://cloud.google.com\
                /appengine/flexible
        .. _Metadata Service: https://cloud.google.com/compute/docs\
                /storing-retrieving-metadata
        .. _Cloud Run: https://cloud.google.com/run
        .. _Google Distributed Cloud Hosted: https://cloud.google.com/blog/topics\
                /hybrid-cloud/announcing-google-distributed-cloud-edge-and-hosted
    
        Example::
    
            import google.auth
    
            credentials, project_id = google.auth.default()
    
        Args:
            scopes (Sequence[str]): The list of scopes for the credentials. If
                specified, the credentials will automatically be scoped if
                necessary.
            request (Optional[google.auth.transport.Request]): An object used to make
                HTTP requests. This is used to either detect whether the application
                is running on Compute Engine or to determine the associated project
                ID for a workload identity pool resource (external account
                credentials). If not specified, then it will either use the standard
                library http client to make requests for Compute Engine credentials
                or a google.auth.transport.requests.Request client for external
                account credentials.
            quota_project_id (Optional[str]): The project ID used for
                quota and billing.
            default_scopes (Optional[Sequence[str]]): Default scopes passed by a
                Google client library. Use 'scopes' for user-defined scopes.
        Returns:
            Tuple[~google.auth.credentials.Credentials, Optional[str]]:
                the current environment's credentials and project ID. Project ID
                may be None, which indicates that the Project ID could not be
                ascertained from the environment.
    
        Raises:
            ~google.auth.exceptions.DefaultCredentialsError:
                If no credentials were found, or if the credentials found were
                invalid.
        """
        from google.auth.credentials import with_scopes_if_required
        from google.auth.credentials import CredentialsWithQuotaProject
    
        explicit_project_id = os.environ.get(
            environment_vars.PROJECT, os.environ.get(environment_vars.LEGACY_PROJECT)
        )
    
        checkers = (
            # Avoid passing scopes here to prevent passing scopes to user credentials.
            # with_scopes_if_required() below will ensure scopes/default scopes are
            # safely set on the returned credentials since requires_scopes will
            # guard against setting scopes on user credentials.
            lambda: _get_explicit_environ_credentials(quota_project_id=quota_project_id),
            lambda: _get_gcloud_sdk_credentials(quota_project_id=quota_project_id),
            _get_gae_credentials,
            lambda: _get_gce_credentials(request, quota_project_id=quota_project_id),
        )
    
        for checker in checkers:
            credentials, project_id = checker()
            if credentials is not None:
                credentials = with_scopes_if_required(
                    credentials, scopes, default_scopes=default_scopes
                )
    
                effective_project_id = explicit_project_id or project_id
    
                # For external account credentials, scopes are required to determine
                # the project ID. Try to get the project ID again if not yet
                # determined.
                if not effective_project_id and callable(
                    getattr(credentials, "get_project_id", None)
                ):
                    if request is None:
                        import google.auth.transport.requests
    
                        request = google.auth.transport.requests.Request()
                    effective_project_id = credentials.get_project_id(request=request)
    
                if quota_project_id and isinstance(
                    credentials, CredentialsWithQuotaProject
                ):
                    credentials = credentials.with_quota_project(quota_project_id)
    
                if not effective_project_id:
                    _LOGGER.warning(
                        "No project ID could be determined. Consider running "
                        "`gcloud config set project` or setting the %s "
                        "environment variable",
                        environment_vars.PROJECT,
                    )
                return credentials, effective_project_id
    
>       raise exceptions.DefaultCredentialsError(_CLOUD_SDK_MISSING_CREDENTIALS)
E       google.auth.exceptions.DefaultCredentialsError: Your default credentials were not found. To set up Application Default Credentials, see https://cloud.google.com/docs/authentication/external/set-up-adc for more information.

.venv/lib/python3.12/site-packages/google/auth/_default.py:739: DefaultCredentialsError
_________________________ test_submit_feedback_success _________________________

override_get_current_user = None, override_get_feedback_service = None
mock_current_user = AuthenticatedUser(id=UUID('a6c11c10-263a-4ebf-9450-2424038e3e59'), tenant_id=UUID('43c47b95-c4c3-4932-afb6-21f4da731f97'), email='test@example.com', is_active=True, is_admin=False)
mock_feedback_service = <AsyncMock spec='FeedbackService' id='139819072755648'>

    @pytest.mark.asyncio
    async def test_submit_feedback_success(
        override_get_current_user,
        override_get_feedback_service,
        mock_current_user,
        mock_feedback_service
    ):
        """
        フィードバック送信APIの成功ケースをテストします。
        """
        feedback_id = uuid4()
        session_id = uuid4()
        message_id = uuid4()
        feedback_data = FeedbackCreate(
            session_id=session_id,
            message_id=message_id,
            rating=1,
            comment="Great response!"
        )
        mock_feedback_service.create_feedback.return_value = FeedbackResponse(
            id=feedback_id,
            tenant_id=mock_current_user.tenant_id,
            user_id=mock_current_user.id,
            session_id=session_id,
            message_id=message_id,
            rating=feedback_data.rating,
            comment=feedback_data.comment,
            created_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc)
        )
    
        response = client.post("/api/v1/feedback", json=jsonable_encoder(feedback_data.model_dump()))
>       assert response.status_code == 201
E       assert 404 == 201
E        +  where 404 = <Response [404 Not Found]>.status_code

app/tests/test_endpoints_feedback.py:78: AssertionError
____________________ test_get_feedback_for_session_success _____________________

override_get_current_user = None, override_get_feedback_service = None
mock_current_user = AuthenticatedUser(id=UUID('f92da809-0749-41c1-9ee1-2a5930687f87'), tenant_id=UUID('53a2bee2-70bb-43d8-aa73-ed0a8f1b53c9'), email='test@example.com', is_active=True, is_admin=False)
mock_feedback_service = <AsyncMock spec='FeedbackService' id='139819073371504'>

    @pytest.mark.asyncio
    async def test_get_feedback_for_session_success(
        override_get_current_user,
        override_get_feedback_service,
        mock_current_user,
        mock_feedback_service
    ):
        """
        セッションIDによるフィードバック取得の成功ケースをテストします。
        """
        session_id = uuid4()
        feedback_1 = FeedbackResponse(
            id=uuid4(), tenant_id=mock_current_user.tenant_id, user_id=mock_current_user.id, session_id=session_id,
            rating=1, comment="Good", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc)
        )
        feedback_2 = FeedbackResponse(
            id=uuid4(), tenant_id=mock_current_user.tenant_id, user_id=mock_current_user.id, session_id=session_id,
            rating=-1, comment="Bad", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc)
        )
        mock_feedback_service.get_feedback_by_session_id.return_value = [feedback_1, feedback_2]
    
        response = client.get(f"/api/v1/feedback/{session_id}")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app/tests/test_endpoints_feedback.py:109: AssertionError
____________________ test_get_feedback_for_message_success _____________________

override_get_current_user = None, override_get_feedback_service = None
mock_current_user = AuthenticatedUser(id=UUID('b5ed51c0-db17-49c4-a30d-6d241d6c9732'), tenant_id=UUID('0fbc281a-e19e-4c07-8ab2-ccd3f4407d48'), email='test@example.com', is_active=True, is_admin=False)
mock_feedback_service = <AsyncMock spec='FeedbackService' id='139819073402496'>

    @pytest.mark.asyncio
    async def test_get_feedback_for_message_success(
        override_get_current_user,
        override_get_feedback_service,
        mock_current_user,
        mock_feedback_service
    ):
        """
        メッセージIDによるフィードバック取得の成功ケースをテストします。
        """
        message_id = uuid4()
        feedback = FeedbackResponse(
            id=uuid4(), tenant_id=mock_current_user.tenant_id, user_id=mock_current_user.id, session_id=uuid4(),
            message_id=message_id, rating=1, comment="Very helpful", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc)
        )
        mock_feedback_service.get_feedback_by_message_id.return_value = feedback
    
        response = client.get(f"/api/v1/feedback/message/{message_id}")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app/tests/test_endpoints_feedback.py:132: AssertionError
___________________ test_get_feedback_for_message_not_found ____________________

override_get_current_user = None, override_get_feedback_service = None
mock_feedback_service = <AsyncMock spec='FeedbackService' id='139819073392560'>

    @pytest.mark.asyncio
    async def test_get_feedback_for_message_not_found(
        override_get_current_user,
        override_get_feedback_service,
        mock_feedback_service
    ):
        """
        メッセージIDによるフィードバックが見つからない場合のテスト。
        """
        message_id = uuid4()
        mock_feedback_service.get_feedback_by_message_id.return_value = None
    
        response = client.get(f"/api/v1/feedback/message/{message_id}")
>       assert response.status_code == 200 # Optional[FeedbackResponse]なのでNoneを返す場合は200
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app/tests/test_endpoints_feedback.py:149: AssertionError
__________________ test_get_feedback_for_message_unauthorized __________________

override_get_current_user = None, override_get_feedback_service = None
mock_feedback_service = <AsyncMock spec='FeedbackService' id='139819073468272'>

    @pytest.mark.asyncio
    async def test_get_feedback_for_message_unauthorized(
        override_get_current_user,
        override_get_feedback_service,
        mock_feedback_service
    ):
        """
        メッセージIDによるフィードバック取得で権限がない場合のテスト。
        """
        message_id = uuid4()
        # 別のテナントのフィードバックを返すようにモック
        unauthorized_feedback = FeedbackResponse(
            id=uuid4(), tenant_id=uuid4(), user_id=uuid4(), session_id=uuid4(),
            message_id=message_id, rating=1, comment="Not yours", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc)
        )
        mock_feedback_service.get_feedback_by_message_id.return_value = unauthorized_feedback
    
        response = client.get(f"/api/v1/feedback/message/{message_id}")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app/tests/test_endpoints_feedback.py:171: AssertionError
_____________________ test_upload_file_global_rag_success ______________________

override_get_current_user = None, override_get_file_service = None
override_get_knowledge_document_repository = None
override_get_rag_service = None
mock_current_user = AuthenticatedUser(id=UUID('2491e85c-9764-4fb4-8e7c-b927d2ffefcc'), tenant_id=UUID('c19bf7be-c65e-4357-881d-02a627f66d5b'), email='test@example.com', is_active=True, is_admin=False)
mock_file_service = <AsyncMock spec='FileService' id='139819073688288'>
mock_knowledge_document_repository = <AsyncMock spec='KnowledgeDocumentRepository' id='139819073695536'>
mock_rag_service = <AsyncMock spec='RagService' id='139819073695776'>

    @pytest.mark.asyncio
    async def test_upload_file_global_rag_success(
        override_get_current_user,
        override_get_file_service,
        override_get_knowledge_document_repository,
        override_get_rag_service,
        mock_current_user,
        mock_file_service,
        mock_knowledge_document_repository,
        mock_rag_service
    ):
        """
        ファイルをアップロードし、グローバルRAGに登録する成功ケースをテストします。
        """
        file_content = b"This is a test document."
        mock_file = BytesIO(file_content)
        file_name = "test.txt"
        file_id = uuid4()
    
        mock_file_service.save_file.return_value = MagicMock(
            id=file_id,
            tenant_id=mock_current_user.tenant_id,
            file_name=file_name,
            file_path="/path/to/test.txt",
            file_type="text/plain",
            file_size=str(len(file_content)),
            uploaded_by_user_id=mock_current_user.id,
            is_active=True
        )
        mock_file_service.extract_text_from_knowledge_document.return_value = file_content.decode("utf-8")
        mock_knowledge_document_repository.create.return_value = FileUploadResponse(
            id=file_id,
            tenant_id=mock_current_user.tenant_id,
            file_name=file_name,
            file_path="/path/to/test.txt",
            file_type="text/plain",
            file_size=str(len(file_content)),
            uploaded_by_user_id=mock_current_user.id,
            is_active=True,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        mock_rag_service.add_documents_to_global_rag.return_value = None
    
        response = client.post(
            "/api/v1/files/upload",
            files={"file": (file_name, mock_file, "text/plain")}
        )
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

app/tests/test_endpoints_files.py:118: AssertionError
____________________ test_upload_file_ephemeral_rag_success ____________________

override_get_current_user = None, override_get_file_service = None
override_get_knowledge_document_repository = None
override_get_rag_service = None
mock_current_user = AuthenticatedUser(id=UUID('60545d79-cf5a-4497-b639-a830d588e136'), tenant_id=UUID('4b485708-759c-4629-ad1f-228e5581d418'), email='test@example.com', is_active=True, is_admin=False)
mock_file_service = <AsyncMock spec='FileService' id='139819072426576'>
mock_knowledge_document_repository = <AsyncMock spec='KnowledgeDocumentRepository' id='139819072422640'>
mock_rag_service = <AsyncMock spec='RagService' id='139819072432624'>

    @pytest.mark.asyncio
    async def test_upload_file_ephemeral_rag_success(
        override_get_current_user,
        override_get_file_service,
        override_get_knowledge_document_repository,
        override_get_rag_service,
        mock_current_user,
        mock_file_service,
        mock_knowledge_document_repository,
        mock_rag_service
    ):
        """
        ファイルをアップロードし、Ephemeral RAGに登録する成功ケースをテストします。
        """
        file_content = b"This is a session-specific document."
        mock_file = BytesIO(file_content)
        file_name = "session_doc.md"
        file_id = uuid4()
        session_id = uuid4()
    
        mock_file_service.save_file.return_value = MagicMock(
            id=file_id,
            tenant_id=mock_current_user.tenant_id,
            file_name=file_name,
            file_path="/path/to/session_doc.md",
            file_type="text/markdown",
            file_size=str(len(file_content)),
            uploaded_by_user_id=mock_current_user.id,
            is_active=True
        )
        mock_file_service.extract_text_from_knowledge_document.return_value = file_content.decode("utf-8")
        mock_knowledge_document_repository.create.return_value = FileUploadResponse(
            id=file_id,
            tenant_id=mock_current_user.tenant_id,
            file_name=file_name,
            file_path="/path/to/session_doc.md",
            file_type="text/markdown",
            file_size=str(len(file_content)),
            uploaded_by_user_id=mock_current_user.id,
            is_active=True,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        mock_rag_service.add_documents_to_ephemeral_rag.return_value = None
    
        response = client.post(
            f"/api/v1/files/upload?session_id={session_id}",
            files={"file": (file_name, mock_file, "text/markdown")}
        )
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

app/tests/test_endpoints_files.py:176: AssertionError
_________________________ test_upload_file_no_filename _________________________

override_get_current_user = None, override_get_file_service = None

    @pytest.mark.asyncio
    async def test_upload_file_no_filename(
        override_get_current_user,
        override_get_file_service,
    ):
        """
        ファイル名がない場合のアップロード失敗ケースをテストします。
        """
        response = client.post(
            "/api/v1/files/upload",
            files={"file": (None, BytesIO(b"content"), "text/plain")}
        )
        assert response.status_code == 400
>       assert "No file name provided." in response.json()["detail"]
E       AssertionError: assert 'No file name provided.' in 'There was an error parsing the body'

app/tests/test_endpoints_files.py:199: AssertionError
______________________ test_upload_file_validation_error _______________________

override_get_current_user = None, override_get_file_service = None
mock_file_service = <AsyncMock spec='FileService' id='139819049613216'>

    @pytest.mark.asyncio
    async def test_upload_file_validation_error(
        override_get_current_user,
        override_get_file_service,
        mock_file_service
    ):
        """
        ファイルバリデーションエラー時のアップロード失敗ケースをテストします。
        """
        mock_file_service.save_file.side_effect = HTTPException(
            status_code=413, detail="File size exceeds the limit."
        )
    
        response = client.post(
            "/api/v1/files/upload",
>           files={"file": ("large_file.txt", BytesIO(b"a"* (settings.MAX_FILE_SIZE_MB * 1024 * 1024 + 1)), "text/plain")}
                                                             ^^^^^^^^
        )
E       NameError: name 'settings' is not defined

app/tests/test_endpoints_files.py:217: NameError
_______________________ test_rag_service_initialization ________________________

mock_tenant_id = UUID('60d04f13-d483-4714-9ee0-6210da4af797')
mock_llm_client = <AsyncMock spec='MockLLMClient' id='139819072461456'>
mock_pgvector = <MagicMock name='PGVector' spec='PGVector' id='139819049603664'>
mock_embeddings = <MagicMock name='GoogleGenerativeAIEmbeddings' spec='GoogleGenerativeAIEmbeddings' id='139819045201696'>
mock_chat_google_generative_ai = <MagicMock name='ChatGoogleGenerativeAI' spec='ChatGoogleGenerativeAI' id='139819054615296'>

    @pytest.mark.asyncio
    async def test_rag_service_initialization(
        mock_tenant_id,
        mock_llm_client,
        mock_pgvector,
        mock_embeddings,
        mock_chat_google_generative_ai
    ):
        """RagServiceが正しく初期化されることをテスト"""
        service = RagService(tenant_id=mock_tenant_id, llm_client=mock_llm_client)
    
        mock_embeddings.assert_called_once_with(model="models/embedding-001")
        mock_pgvector.assert_called_once_with(
            collection_name=f"{settings.PG_COLLECTION_NAME}_{str(mock_tenant_id).replace('-', '_')}",
            connection=settings.DATABASE_URL,
            embeddings=mock_embeddings.return_value,
        )
        mock_chat_google_generative_ai.assert_called_once_with(model="gemini-pro")
        assert service.tenant_id == mock_tenant_id
        assert service.llm_client == mock_llm_client
>       assert service.retriever == mock_pgvector.return_value.as_retriever.return_value
               ^^^^^^^^^^^^^^^^^
E       AttributeError: 'RagService' object has no attribute 'retriever'

app/tests/test_rag_service.py:79: AttributeError
________________ test_user_repository_get_by_email_with_tenant _________________

user_repo_with_tenant = <app.repositories.user.UserRepository object at 0x7f2a283e8e30>
mock_session = <AsyncMock spec='AsyncSession' id='139819040541920'>

    @pytest.mark.asyncio
    async def test_user_repository_get_by_email_with_tenant(user_repo_with_tenant, mock_session):
        """UserRepository.get_by_email() (tenant_idあり)のテスト"""
        test_email = "test@example.com"
        mock_user = User(id=uuid4(), tenant_id=user_repo_with_tenant.tenant_id, email=test_email, hashed_password="pw")
        mock_session.execute.return_value.scalar_one_or_none.return_value = mock_user
    
        user = await user_repo_with_tenant.get_by_email(test_email)
        assert user == mock_user
        # select文にtenant_idのwhere句があることを確認
>       assert mock_session.execute.call_args[0][0].compare(
            select(User).where(User.email == test_email, User.tenant_id == user_repo_with_tenant.tenant_id)
        )
E       AssertionError: assert False
E        +  where False = compare(<sqlalchemy.sql.selectable.Select object at 0x7f2a283e9d30>)
E        +    where compare = <sqlalchemy.sql.selectable.Select object at 0x7f2a283e9640>.compare
E        +    and   <sqlalchemy.sql.selectable.Select object at 0x7f2a283e9d30> = where(<sqlalchemy.orm.attributes.InstrumentedAttribute object at 0x7f2a6f105ee0> == 'test@example.com', <sqlalchemy.orm.attributes.InstrumentedAttribute object at 0x7f2a6f1060c0> == UUID('ff58b77d-c3d2-4d53-9972-08827f505f6c'))
E        +      where where = <sqlalchemy.sql.selectable.Select object at 0x7f2a283e9700>.where
E        +        where <sqlalchemy.sql.selectable.Select object at 0x7f2a283e9700> = select(User)
E        +      and   <sqlalchemy.orm.attributes.InstrumentedAttribute object at 0x7f2a6f105ee0> = User.email
E        +      and   <sqlalchemy.orm.attributes.InstrumentedAttribute object at 0x7f2a6f1060c0> = User.tenant_id
E        +      and   UUID('ff58b77d-c3d2-4d53-9972-08827f505f6c') = <app.repositories.user.UserRepository object at 0x7f2a283e8e30>.tenant_id

app/tests/test_repositories.py:116: AssertionError
=============================== warnings summary ===============================
app/schemas/auth.py:4
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/auth.py:4: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class AuthenticatedUser(BaseModel):

app/schemas/chat.py:15
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/chat.py:15: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatMessageResponse(BaseModel):

app/schemas/chat.py:36
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/chat.py:36: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatSessionResponse(BaseModel):

app/schemas/file.py:5
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/file.py:5: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class FileUploadResponse(BaseModel):

app/schemas/feedback.py:16
  /home/masahiro/work/dom-enterprise-gateway/backend/app/schemas/feedback.py:16: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class FeedbackResponse(BaseModel):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED app/tests/test_endpoints_chat.py::test_stream_chat_response_unauthorized_session
FAILED app/tests/test_endpoints_feedback.py::test_submit_feedback_success - a...
FAILED app/tests/test_endpoints_feedback.py::test_get_feedback_for_session_success
FAILED app/tests/test_endpoints_feedback.py::test_get_feedback_for_message_success
FAILED app/tests/test_endpoints_feedback.py::test_get_feedback_for_message_not_found
FAILED app/tests/test_endpoints_feedback.py::test_get_feedback_for_message_unauthorized
FAILED app/tests/test_endpoints_files.py::test_upload_file_global_rag_success
FAILED app/tests/test_endpoints_files.py::test_upload_file_ephemeral_rag_success
FAILED app/tests/test_endpoints_files.py::test_upload_file_no_filename - Asse...
FAILED app/tests/test_endpoints_files.py::test_upload_file_validation_error
FAILED app/tests/test_rag_service.py::test_rag_service_initialization - Attri...
FAILED app/tests/test_repositories.py::test_user_repository_get_by_email_with_tenant
ERROR app/tests/test_rag_service.py::test_query_rag - AssertionError: assert ...
ERROR app/tests/test_rag_service.py::test_add_documents - AssertionError: ass...
ERROR app/tests/test_rag_service.py::test_stream_rag_response - AssertionErro...
============= 12 failed, 39 passed, 5 warnings, 3 errors in 14.19s =============
